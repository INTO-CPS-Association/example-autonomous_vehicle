/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmodel.c
 *  model: robotti_V3_hc
 *  expmt: robotti_V3_hc
 *  date:  October 17, 2017
 *  time:  1:03:17 PM
 *  user:  INTO-CPS
 *  from:  20-sim 4.6 Professional Single
 *  build: 4.6.3.7711
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXCharacter *xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"
#include "xxmatrix.h"


#if (36 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
/* this method is called before calculation is possible */
void XXModelInitialize (xx_ModelInstance* model_instance)
{
	/* set the constants */
	xx_C[0] = 3.14159265358979;		/* pi {} */


	/* set the parameters */
	xx_P[0] = 0.0;		/* dist_b */
	xx_P[1] = 0.55;		/* mu */
	xx_P[2] = 9.8;		/* BicycleModel\vehicle_model\g */
	xx_P[3] = 680.0;		/* m */
	xx_P[4] = 0.95;		/* cg_a */
	xx_P[5] = 0.55;		/* cg_b */
	xx_P[6] = 34377.0;		/* C_af */
	xx_P[7] = 42972.0;		/* C_ar */
	xx_P[8] = 4096.0;		/* encoder_angle_resolution */
	xx_P[9] = 1024.0;		/* encoder_speed_resolution */
	xx_P[10] = 1.0;		/* motor\encoder1\Quantisize\lsb */
	xx_P[11] = 1.0;		/* motor\encoder1\Quantisize1\lsb */
	xx_P[12] = 1.0;		/* motor\encoder2\Quantisize\lsb */
	xx_P[13] = 1.0;		/* motor\encoder2\Quantisize1\lsb */
	xx_P[14] = 0.29;		/* motor\Gain\K */
	xx_P[15] = 3.2;		/* motor\Limit\maximum */
	xx_P[16] = -3.0;		/* motor\Limit\minimum */
	xx_P[17] = 1.0;		/* motor\TransferFunction\k */
	xx_P[18] = 0.3;		/* motor\TransferFunction\tau */
	xx_P[19] = 0.29;		/* motor\wheel\R */
	xx_P[20] = 1.2;		/* PosCalc\gnss_x */
	xx_P[21] = 0.0;		/* PosCalc\gnss_y */
	xx_P[22] = 1.0;		/* pvg_actuator\encoder\Quantisize\lsb */
	xx_P[23] = 1.0;		/* pvg_actuator\encoder\Quantisize1\lsb */
	xx_P[24] = 1.0;		/* pvg_actuator\encoder1\Quantisize\lsb */
	xx_P[25] = 1.0;		/* pvg_actuator\encoder1\Quantisize1\lsb */
	xx_P[26] = 1.31;		/* pvg_actuator\Limit\maximum */
	xx_P[27] = -1.31;		/* pvg_actuator\Limit\minimum */
	xx_P[28] = 1.31;		/* pvg_actuator\Limit_left\maximum */
	xx_P[29] = -1.31;		/* pvg_actuator\Limit_left\minimum */
	xx_P[30] = 1.31;		/* pvg_actuator\Limit_right\maximum */
	xx_P[31] = -1.31;		/* pvg_actuator\Limit_right\minimum */
	xx_P[32] = 1.0;		/* pvg_actuator\TransferFunction\k */
	xx_P[33] = 0.2;		/* pvg_actuator\TransferFunction\tau */
	xx_P[34] = 1.0;		/* pvg_actuator\TransferFunction1\k */
	xx_P[35] = 0.2;		/* pvg_actuator\TransferFunction1\tau */


	/* set the initial values */
	xx_I[0] = 0.0;		/* BicycleModel\vehicle_model\v_initial */
	xx_I[1] = 0.0;		/* BicycleModel\vehicle_model\r_initial */
	xx_I[2] = 0.0;		/* motor\TransferFunction\state_initial */
	xx_I[3] = 0.0;		/* motor\wheel\initial */
	xx_I[4] = 0.0;		/* PosCalc\temp_theta_initial */
	xx_I[5] = 0.0;		/* PosCalc\x_initial */
	xx_I[6] = 0.0;		/* PosCalc\y_initial */
	xx_I[7] = 0.0;		/* pvg_actuator\TransferFunction\state_initial */
	xx_I[8] = 0.0;		/* pvg_actuator\TransferFunction1\state_initial */


	/* set the states */
	xx_s[0] = xx_I[0];		/* BicycleModel\vehicle_model\v */
	xx_s[1] = xx_I[1];		/* BicycleModel\vehicle_model\r */
	xx_s[2] = xx_I[2];		/* motor\TransferFunction\state */
	xx_s[3] = xx_I[3];		/* motor\wheel\output */
	xx_s[4] = xx_I[4];		/* PosCalc\temp_theta */
	xx_s[5] = xx_I[5];		/* PosCalc\x */
	xx_s[6] = xx_I[6];		/* PosCalc\y */
	xx_s[7] = xx_I[7];		/* pvg_actuator\TransferFunction\state */
	xx_s[8] = xx_I[8];		/* pvg_actuator\TransferFunction1\state */


	/* set the matrices */
	xx_M[0].mat = &xx_V[38];		/* PosCalc\P_1 */
	xx_M[0].rows = 2;
	xx_M[0].columns = 1;
	xx_M[1].mat = &xx_V[40];		/* PosCalc\P_GNSS */
	xx_M[1].rows = 2;
	xx_M[1].columns = 1;
	xx_M[2].mat = &xx_V[42];		/* PosCalc\R */
	xx_M[2].rows = 2;
	xx_M[2].columns = 2;
	xx_M[3].mat = &xx_U[0];		/* xx_U1 */
	xx_M[3].rows = 2;
	xx_M[3].columns = 2;


}
#if (36 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void XXCalculateInitial (xx_ModelInstance* model_instance)
{
		/* BicycleModel\vehicle_model\L = cg_a + cg_b; */
		xx_V[3] = xx_P[4] + xx_P[5];

		/* BicycleModel\vehicle_model\a = BicycleModel\vehicle_model\L - (cg_b - dist_b); */
		xx_V[0] = xx_V[3] - (xx_P[5] - xx_P[0]);

		/* BicycleModel\vehicle_model\b = BicycleModel\vehicle_model\L - (cg_a + dist_b); */
		xx_V[1] = xx_V[3] - (xx_P[4] + xx_P[0]);

		/* I_zz = (m / 4) * ((BicycleModel\vehicle_model\a + BicycleModel\vehicle_model\b) ^ 2); */
		xx_V[2] = (xx_P[3] / 4.0) * (XXPow2 ((xx_V[0] + xx_V[1])));

		/* BicycleModel\vehicle_model\W_f = (m * BicycleModel\vehicle_model\g) * (BicycleModel\vehicle_model\b / BicycleModel\vehicle_model\L); */
		xx_V[5] = (xx_P[3] * xx_P[2]) * (xx_V[1] / xx_V[3]);

		/* BicycleModel\vehicle_model\W_r = (m * BicycleModel\vehicle_model\g) * (BicycleModel\vehicle_model\a / BicycleModel\vehicle_model\L); */
		xx_V[4] = (xx_P[3] * xx_P[2]) * (xx_V[0] / xx_V[3]);

		/* BicycleModel\vehicle_model\h_s_f = (BicycleModel\vehicle_model\W_f * mu) / 2; */
		xx_V[8] = (xx_V[5] * xx_P[1]) / 2.0;

		/* BicycleModel\vehicle_model\h_s_r = (BicycleModel\vehicle_model\W_r * mu) / 2; */
		xx_V[9] = (xx_V[4] * xx_P[1]) / 2.0;

		/* PosCalc\P_1 = [PosCalc\gnss_x; PosCalc\gnss_y]; */
		xx_M[0].mat[0] = xx_P[20];
		xx_M[0].mat[1] = xx_P[21];


	/* set the states */
	xx_s[0] = xx_I[0];		/* BicycleModel\vehicle_model\v */
	xx_s[1] = xx_I[1];		/* BicycleModel\vehicle_model\r */
	xx_s[2] = xx_I[2];		/* motor\TransferFunction\state */
	xx_s[3] = xx_I[3];		/* motor\wheel\output */
	xx_s[4] = xx_I[4];		/* PosCalc\temp_theta */
	xx_s[5] = xx_I[5];		/* PosCalc\x */
	xx_s[6] = xx_I[6];		/* PosCalc\y */
	xx_s[7] = xx_I[7];		/* pvg_actuator\TransferFunction\state */
	xx_s[8] = xx_I[8];		/* pvg_actuator\TransferFunction1\state */


}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void XXCalculateStatic (xx_ModelInstance* model_instance)
{
	/* motor\encoder1\Quantisize\half_lsb = motor\encoder1\Quantisize\lsb / 2; */
	xx_V[20] = xx_P[10] / 2.0;

	/* motor\encoder1\Quantisize1\half_lsb = motor\encoder1\Quantisize1\lsb / 2; */
	xx_V[23] = xx_P[11] / 2.0;

	/* motor\encoder2\Quantisize\half_lsb = motor\encoder2\Quantisize\lsb / 2; */
	xx_V[30] = xx_P[12] / 2.0;

	/* motor\encoder2\Quantisize1\half_lsb = motor\encoder2\Quantisize1\lsb / 2; */
	xx_V[33] = xx_P[13] / 2.0;

	/* pvg_actuator\encoder\Quantisize\half_lsb = pvg_actuator\encoder\Quantisize\lsb / 2; */
	xx_V[54] = xx_P[22] / 2.0;

	/* pvg_actuator\encoder\Quantisize1\half_lsb = pvg_actuator\encoder\Quantisize1\lsb / 2; */
	xx_V[57] = xx_P[23] / 2.0;

	/* pvg_actuator\encoder1\Quantisize\half_lsb = pvg_actuator\encoder1\Quantisize\lsb / 2; */
	xx_V[64] = xx_P[24] / 2.0;

	/* pvg_actuator\encoder1\Quantisize1\half_lsb = pvg_actuator\encoder1\Quantisize1\lsb / 2; */
	xx_V[67] = xx_P[25] / 2.0;

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void XXCalculateInput (xx_ModelInstance* model_instance)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (xx_ModelInstance* model_instance)
{
	/* PosCalc\theta = atan2 (sin (PosCalc\temp_theta), cos (PosCalc\temp_theta)); */
	xx_V[37] = atan2 (sin (xx_s[4]), cos (xx_s[4]));

	/* PosCalc\R = [cos (PosCalc\theta), sin (PosCalc\theta); -sin (PosCalc\theta), cos (PosCalc\theta)]; */
	xx_M[2].mat[0] = cos (xx_V[37]);
	xx_M[2].mat[1] = sin (xx_V[37]);
	xx_M[2].mat[2] = -(sin (xx_V[37]));
	xx_M[2].mat[3] = cos (xx_V[37]);

	/* Splitter3\input = delta_w; */
	xx_V[72] = xx_V[73];

	/* theta = PosCalc\theta; */
	xx_V[81] = xx_V[37];

	/* x = PosCalc\x; */
	xx_V[82] = xx_s[5];

	/* y = PosCalc\y; */
	xx_V[83] = xx_s[6];

	/* motor\u_r_w = u_r; */
	xx_V[36] = xx_V[92];

	/* motor\Limit\output = (if motor\TransferFunction\state < motor\Limit\minimum then motor\Limit\minimum else (if motor\TransferFunction\state > motor\Limit\maximum then motor\Limit\maximum else motor\TransferFunction\state end) end); */
	xx_V[35] = ((xx_s[2] < xx_P[16]) ? 
		/* motor\Limit\minimum */
		xx_P[16]
	:
		/* (if motor\TransferFunction\state > motor\Limit\maximum then motor\Limit\maximum else motor\TransferFunction\state end) */
		((xx_s[2] > xx_P[15]) ? 
			/* motor\Limit\maximum */
			xx_P[15]
		:
			/* motor\TransferFunction\state */
			xx_s[2]
		)
	);

	/* PosCalc\r_a = BicycleModel\vehicle_model\r; */
	xx_R[4] = xx_s[1];

	/* motor\Gain\output = motor\Gain\K * motor\u_r_w; */
	xx_V[34] = xx_P[14] * xx_V[36];

	/* motor\Differentiate1\output_in = motor\Limit\output / motor\wheel\R; */
	xx_V[93] = xx_V[35] / xx_P[19];

	/* motor\Differentiate2\output_in = motor\Limit\output / motor\wheel\R; */
	xx_V[94] = xx_V[35] / xx_P[19];

	/* motor\TransferFunction\rate = (motor\TransferFunction\k * motor\Gain\output - motor\TransferFunction\state) / motor\TransferFunction\tau; */
	xx_R[2] = (xx_P[17] * xx_V[34] - xx_s[2]) / xx_P[18];

	/* motor\wheel\w_r = motor\Limit\output / motor\wheel\R; */
	xx_R[3] = xx_V[35] / xx_P[19];

	/* pvg_actuator\encoder\AngleToLinearDistance\output = (pvg_actuator\TransferFunction1\state * encoder_angle_resolution) / (2 * pi); */
	xx_V[48] = (xx_s[8] * xx_P[8]) / (2.0 * xx_C[0]);

	/* pvg_actuator\encoder1\AngleToLinearDistance\output = (pvg_actuator\TransferFunction\state * encoder_angle_resolution) / (2 * pi); */
	xx_V[58] = (xx_s[7] * xx_P[8]) / (2.0 * xx_C[0]);

	/* pvg_actuator\Limit_left\output = (if Splitter3\input < pvg_actuator\Limit_left\minimum then pvg_actuator\Limit_left\minimum else (if Splitter3\input > pvg_actuator\Limit_left\maximum then pvg_actuator\Limit_left\maximum else Splitter3\input end) end); */
	xx_V[69] = ((xx_V[72] < xx_P[29]) ? 
		/* pvg_actuator\Limit_left\minimum */
		xx_P[29]
	:
		/* (if Splitter3\input > pvg_actuator\Limit_left\maximum then pvg_actuator\Limit_left\maximum else Splitter3\input end) */
		((xx_V[72] > xx_P[28]) ? 
			/* pvg_actuator\Limit_left\maximum */
			xx_P[28]
		:
			/* Splitter3\input */
			xx_V[72]
		)
	);

	/* pvg_actuator\Limit_right\output = (if Splitter3\input < pvg_actuator\Limit_right\minimum then pvg_actuator\Limit_right\minimum else (if Splitter3\input > pvg_actuator\Limit_right\maximum then pvg_actuator\Limit_right\maximum else Splitter3\input end) end); */
	xx_V[70] = ((xx_V[72] < xx_P[31]) ? 
		/* pvg_actuator\Limit_right\minimum */
		xx_P[31]
	:
		/* (if Splitter3\input > pvg_actuator\Limit_right\maximum then pvg_actuator\Limit_right\maximum else Splitter3\input end) */
		((xx_V[72] > xx_P[30]) ? 
			/* pvg_actuator\Limit_right\maximum */
			xx_P[30]
		:
			/* Splitter3\input */
			xx_V[72]
		)
	);

	/* pvg_actuator\steering\delta_f = (pvg_actuator\TransferFunction\state + pvg_actuator\TransferFunction1\state) / 2; */
	xx_V[71] = (xx_s[7] + xx_s[8]) / 2.0;

	/* pvg_actuator\Differentiate\output_in = (pvg_actuator\TransferFunction1\k * pvg_actuator\Limit_right\output - pvg_actuator\TransferFunction1\state) / pvg_actuator\TransferFunction1\tau; */
	xx_V[95] = (xx_P[34] * xx_V[70] - xx_s[8]) / xx_P[35];

	/* pvg_actuator\Differentiate1\output_in = (pvg_actuator\TransferFunction\k * pvg_actuator\Limit_left\output - pvg_actuator\TransferFunction\state) / pvg_actuator\TransferFunction\tau; */
	xx_V[96] = (xx_P[32] * xx_V[69] - xx_s[7]) / xx_P[33];

	/* pvg_actuator\encoder\Quantisize\q = (if pvg_actuator\encoder\AngleToLinearDistance\output < 0.0 then pvg_actuator\encoder\AngleToLinearDistance\output - pvg_actuator\encoder\Quantisize\half_lsb else pvg_actuator\encoder\AngleToLinearDistance\output + pvg_actuator\encoder\Quantisize\half_lsb end); */
	xx_V[53] = ((xx_V[48] < 0.0) ? 
		/* pvg_actuator\encoder\AngleToLinearDistance\output - pvg_actuator\encoder\Quantisize\half_lsb */
		(xx_V[48] - xx_V[54])
	:
		/* pvg_actuator\encoder\AngleToLinearDistance\output + pvg_actuator\encoder\Quantisize\half_lsb */
		(xx_V[48] + xx_V[54])
	);

	/* pvg_actuator\encoder\Quantisize\output = pvg_actuator\encoder\Quantisize\q - (pvg_actuator\encoder\Quantisize\q mod pvg_actuator\encoder\Quantisize\lsb); */
	xx_V[52] = xx_V[53] - (XXIntegerModulo (xx_V[53], xx_P[22]));

	/* pvg_actuator\encoder1\Quantisize\q = (if pvg_actuator\encoder1\AngleToLinearDistance\output < 0.0 then pvg_actuator\encoder1\AngleToLinearDistance\output - pvg_actuator\encoder1\Quantisize\half_lsb else pvg_actuator\encoder1\AngleToLinearDistance\output + pvg_actuator\encoder1\Quantisize\half_lsb end); */
	xx_V[63] = ((xx_V[58] < 0.0) ? 
		/* pvg_actuator\encoder1\AngleToLinearDistance\output - pvg_actuator\encoder1\Quantisize\half_lsb */
		(xx_V[58] - xx_V[64])
	:
		/* pvg_actuator\encoder1\AngleToLinearDistance\output + pvg_actuator\encoder1\Quantisize\half_lsb */
		(xx_V[58] + xx_V[64])
	);

	/* pvg_actuator\encoder1\Quantisize\output = pvg_actuator\encoder1\Quantisize\q - (pvg_actuator\encoder1\Quantisize\q mod pvg_actuator\encoder1\Quantisize\lsb); */
	xx_V[62] = xx_V[63] - (XXIntegerModulo (xx_V[63], xx_P[24]));

	/* pvg_actuator\Limit\output = (if pvg_actuator\steering\delta_f < pvg_actuator\Limit\minimum then pvg_actuator\Limit\minimum else (if pvg_actuator\steering\delta_f > pvg_actuator\Limit\maximum then pvg_actuator\Limit\maximum else pvg_actuator\steering\delta_f end) end); */
	xx_V[68] = ((xx_V[71] < xx_P[27]) ? 
		/* pvg_actuator\Limit\minimum */
		xx_P[27]
	:
		/* (if pvg_actuator\steering\delta_f > pvg_actuator\Limit\maximum then pvg_actuator\Limit\maximum else pvg_actuator\steering\delta_f end) */
		((xx_V[71] > xx_P[26]) ? 
			/* pvg_actuator\Limit\maximum */
			xx_P[26]
		:
			/* pvg_actuator\steering\delta_f */
			xx_V[71]
		)
	);

	/* pvg_actuator\TransferFunction\rate = (pvg_actuator\TransferFunction\k * pvg_actuator\Limit_left\output - pvg_actuator\TransferFunction\state) / pvg_actuator\TransferFunction\tau; */
	xx_R[7] = (xx_P[32] * xx_V[69] - xx_s[7]) / xx_P[33];

	/* pvg_actuator\TransferFunction1\rate = (pvg_actuator\TransferFunction1\k * pvg_actuator\Limit_right\output - pvg_actuator\TransferFunction1\state) / pvg_actuator\TransferFunction1\tau; */
	xx_R[8] = (xx_P[34] * xx_V[70] - xx_s[8]) / xx_P[35];

	/* motor\encoder1\AngleToLinearDistance\output = (motor\wheel\output * encoder_angle_resolution) / (2 * pi); */
	xx_V[14] = (xx_s[3] * xx_P[8]) / (2.0 * xx_C[0]);

	/* motor\encoder1\AngleToLinearDistance2\output = (motor\Differentiate1\output_in * encoder_speed_resolution) / (2 * pi); */
	xx_V[16] = (xx_V[93] * xx_P[9]) / (2.0 * xx_C[0]);

	/* motor\encoder2\AngleToLinearDistance\output = (motor\wheel\output * encoder_angle_resolution) / (2 * pi); */
	xx_V[24] = (xx_s[3] * xx_P[8]) / (2.0 * xx_C[0]);

	/* motor\encoder2\AngleToLinearDistance2\output = (motor\Differentiate2\output_in * encoder_speed_resolution) / (2 * pi); */
	xx_V[26] = (xx_V[94] * xx_P[9]) / (2.0 * xx_C[0]);

	/* PosCalc\v_x = motor\Limit\output * cos (PosCalc\theta) - BicycleModel\vehicle_model\v * sin (PosCalc\theta); */
	xx_R[5] = xx_V[35] * cos (xx_V[37]) - xx_s[0] * sin (xx_V[37]);

	/* PosCalc\v_y = motor\Limit\output * sin (PosCalc\theta) + BicycleModel\vehicle_model\v * cos (PosCalc\theta); */
	xx_R[6] = xx_V[35] * sin (xx_V[37]) + xx_s[0] * cos (xx_V[37]);

	/* pvg_actuator\encoder\AngleToLinearDistance1\output = (pvg_actuator\encoder\Quantisize\output * (2 * pi)) / encoder_angle_resolution; */
	xx_V[49] = (xx_V[52] * (2.0 * xx_C[0])) / xx_P[8];

	/* pvg_actuator\encoder1\AngleToLinearDistance1\output = (pvg_actuator\encoder1\Quantisize\output * (2 * pi)) / encoder_angle_resolution; */
	xx_V[59] = (xx_V[62] * (2.0 * xx_C[0])) / xx_P[8];

	/* motor\encoder1\Quantisize\q = (if motor\encoder1\AngleToLinearDistance\output < 0.0 then motor\encoder1\AngleToLinearDistance\output - motor\encoder1\Quantisize\half_lsb else motor\encoder1\AngleToLinearDistance\output + motor\encoder1\Quantisize\half_lsb end); */
	xx_V[19] = ((xx_V[14] < 0.0) ? 
		/* motor\encoder1\AngleToLinearDistance\output - motor\encoder1\Quantisize\half_lsb */
		(xx_V[14] - xx_V[20])
	:
		/* motor\encoder1\AngleToLinearDistance\output + motor\encoder1\Quantisize\half_lsb */
		(xx_V[14] + xx_V[20])
	);

	/* motor\encoder1\Quantisize\output = motor\encoder1\Quantisize\q - (motor\encoder1\Quantisize\q mod motor\encoder1\Quantisize\lsb); */
	xx_V[18] = xx_V[19] - (XXIntegerModulo (xx_V[19], xx_P[10]));

	/* motor\encoder1\Quantisize1\q = (if motor\encoder1\AngleToLinearDistance2\output < 0.0 then motor\encoder1\AngleToLinearDistance2\output - motor\encoder1\Quantisize1\half_lsb else motor\encoder1\AngleToLinearDistance2\output + motor\encoder1\Quantisize1\half_lsb end); */
	xx_V[22] = ((xx_V[16] < 0.0) ? 
		/* motor\encoder1\AngleToLinearDistance2\output - motor\encoder1\Quantisize1\half_lsb */
		(xx_V[16] - xx_V[23])
	:
		/* motor\encoder1\AngleToLinearDistance2\output + motor\encoder1\Quantisize1\half_lsb */
		(xx_V[16] + xx_V[23])
	);

	/* motor\encoder1\Quantisize1\output = motor\encoder1\Quantisize1\q - (motor\encoder1\Quantisize1\q mod motor\encoder1\Quantisize1\lsb); */
	xx_V[21] = xx_V[22] - (XXIntegerModulo (xx_V[22], xx_P[11]));

	/* motor\encoder2\Quantisize\q = (if motor\encoder2\AngleToLinearDistance\output < 0.0 then motor\encoder2\AngleToLinearDistance\output - motor\encoder2\Quantisize\half_lsb else motor\encoder2\AngleToLinearDistance\output + motor\encoder2\Quantisize\half_lsb end); */
	xx_V[29] = ((xx_V[24] < 0.0) ? 
		/* motor\encoder2\AngleToLinearDistance\output - motor\encoder2\Quantisize\half_lsb */
		(xx_V[24] - xx_V[30])
	:
		/* motor\encoder2\AngleToLinearDistance\output + motor\encoder2\Quantisize\half_lsb */
		(xx_V[24] + xx_V[30])
	);

	/* motor\encoder2\Quantisize\output = motor\encoder2\Quantisize\q - (motor\encoder2\Quantisize\q mod motor\encoder2\Quantisize\lsb); */
	xx_V[28] = xx_V[29] - (XXIntegerModulo (xx_V[29], xx_P[12]));

	/* motor\encoder2\Quantisize1\q = (if motor\encoder2\AngleToLinearDistance2\output < 0.0 then motor\encoder2\AngleToLinearDistance2\output - motor\encoder2\Quantisize1\half_lsb else motor\encoder2\AngleToLinearDistance2\output + motor\encoder2\Quantisize1\half_lsb end); */
	xx_V[32] = ((xx_V[26] < 0.0) ? 
		/* motor\encoder2\AngleToLinearDistance2\output - motor\encoder2\Quantisize1\half_lsb */
		(xx_V[26] - xx_V[33])
	:
		/* motor\encoder2\AngleToLinearDistance2\output + motor\encoder2\Quantisize1\half_lsb */
		(xx_V[26] + xx_V[33])
	);

	/* motor\encoder2\Quantisize1\output = motor\encoder2\Quantisize1\q - (motor\encoder2\Quantisize1\q mod motor\encoder2\Quantisize1\lsb); */
	xx_V[31] = xx_V[32] - (XXIntegerModulo (xx_V[32], xx_P[13]));

	/* pvg_actuator\encoder\AngleToLinearDistance2\output = (pvg_actuator\Differentiate\output_in * encoder_speed_resolution) / (2 * pi); */
	xx_V[50] = (xx_V[95] * xx_P[9]) / (2.0 * xx_C[0]);

	/* pvg_actuator\encoder1\AngleToLinearDistance2\output = (pvg_actuator\Differentiate1\output_in * encoder_speed_resolution) / (2 * pi); */
	xx_V[60] = (xx_V[96] * xx_P[9]) / (2.0 * xx_C[0]);

	/* motor\encoder1\AngleToLinearDistance1\output = (motor\encoder1\Quantisize\output * (2 * pi)) / encoder_angle_resolution; */
	xx_V[15] = (xx_V[18] * (2.0 * xx_C[0])) / xx_P[8];

	/* motor\encoder1\AngleToLinearDistance3\output = (motor\encoder1\Quantisize1\output * (2 * pi)) / encoder_speed_resolution; */
	xx_V[17] = (xx_V[21] * (2.0 * xx_C[0])) / xx_P[9];

	/* motor\encoder2\AngleToLinearDistance1\output = (motor\encoder2\Quantisize\output * (2 * pi)) / encoder_angle_resolution; */
	xx_V[25] = (xx_V[28] * (2.0 * xx_C[0])) / xx_P[8];

	/* motor\encoder2\AngleToLinearDistance3\output = (motor\encoder2\Quantisize1\output * (2 * pi)) / encoder_speed_resolution; */
	xx_V[27] = (xx_V[31] * (2.0 * xx_C[0])) / xx_P[9];

	/* pvg_actuator\encoder\Quantisize1\q = (if pvg_actuator\encoder\AngleToLinearDistance2\output < 0.0 then pvg_actuator\encoder\AngleToLinearDistance2\output - pvg_actuator\encoder\Quantisize1\half_lsb else pvg_actuator\encoder\AngleToLinearDistance2\output + pvg_actuator\encoder\Quantisize1\half_lsb end); */
	xx_V[56] = ((xx_V[50] < 0.0) ? 
		/* pvg_actuator\encoder\AngleToLinearDistance2\output - pvg_actuator\encoder\Quantisize1\half_lsb */
		(xx_V[50] - xx_V[57])
	:
		/* pvg_actuator\encoder\AngleToLinearDistance2\output + pvg_actuator\encoder\Quantisize1\half_lsb */
		(xx_V[50] + xx_V[57])
	);

	/* pvg_actuator\encoder\Quantisize1\output = pvg_actuator\encoder\Quantisize1\q - (pvg_actuator\encoder\Quantisize1\q mod pvg_actuator\encoder\Quantisize1\lsb); */
	xx_V[55] = xx_V[56] - (XXIntegerModulo (xx_V[56], xx_P[23]));

	/* pvg_actuator\encoder1\Quantisize1\q = (if pvg_actuator\encoder1\AngleToLinearDistance2\output < 0.0 then pvg_actuator\encoder1\AngleToLinearDistance2\output - pvg_actuator\encoder1\Quantisize1\half_lsb else pvg_actuator\encoder1\AngleToLinearDistance2\output + pvg_actuator\encoder1\Quantisize1\half_lsb end); */
	xx_V[66] = ((xx_V[60] < 0.0) ? 
		/* pvg_actuator\encoder1\AngleToLinearDistance2\output - pvg_actuator\encoder1\Quantisize1\half_lsb */
		(xx_V[60] - xx_V[67])
	:
		/* pvg_actuator\encoder1\AngleToLinearDistance2\output + pvg_actuator\encoder1\Quantisize1\half_lsb */
		(xx_V[60] + xx_V[67])
	);

	/* pvg_actuator\encoder1\Quantisize1\output = pvg_actuator\encoder1\Quantisize1\q - (pvg_actuator\encoder1\Quantisize1\q mod pvg_actuator\encoder1\Quantisize1\lsb); */
	xx_V[65] = xx_V[66] - (XXIntegerModulo (xx_V[66], xx_P[25]));

	/* pvg_actuator\encoder\AngleToLinearDistance3\output = (pvg_actuator\encoder\Quantisize1\output * (2 * pi)) / encoder_speed_resolution; */
	xx_V[51] = (xx_V[55] * (2.0 * xx_C[0])) / xx_P[9];

	/* pvg_actuator\encoder1\AngleToLinearDistance3\output = (pvg_actuator\encoder1\Quantisize1\output * (2 * pi)) / encoder_speed_resolution; */
	xx_V[61] = (xx_V[65] * (2.0 * xx_C[0])) / xx_P[9];

	/* if abs (motor\Limit\output) > 0.025 */
	if (XXAbsolute (xx_V[35]) > 0.025)
	{
		/* if (motor\Limit\output > 0) */
		if (xx_V[35] > 0.0)
		{
			/* BicycleModel\vehicle_model\alpha_f = ((BicycleModel\vehicle_model\v + BicycleModel\vehicle_model\a * BicycleModel\vehicle_model\r) / abs (motor\Limit\output)) - pvg_actuator\Limit\output; */
			xx_V[10] = ((xx_s[0] + xx_V[0] * xx_s[1]) / XXAbsolute (xx_V[35])) - xx_V[68];
		}
		else
		{
			/* BicycleModel\vehicle_model\alpha_f = ((BicycleModel\vehicle_model\v + BicycleModel\vehicle_model\a * BicycleModel\vehicle_model\r) / abs (motor\Limit\output)) + pvg_actuator\Limit\output; */
			xx_V[10] = ((xx_s[0] + xx_V[0] * xx_s[1]) / XXAbsolute (xx_V[35])) + xx_V[68];
		}

		/* BicycleModel\vehicle_model\alpha_r = ((BicycleModel\vehicle_model\v - BicycleModel\vehicle_model\b * BicycleModel\vehicle_model\r) / abs (motor\Limit\output)); */
		xx_V[11] = ((xx_s[0] - xx_V[1] * xx_s[1]) / XXAbsolute (xx_V[35]));
	}
	else
	{
		/* BicycleModel\vehicle_model\alpha_f = 0; */
		xx_V[10] = 0.0;

		/* BicycleModel\vehicle_model\alpha_r = 0; */
		xx_V[11] = 0.0;
	}

	/* BicycleModel\vehicle_model\f_y_f = -C_af * tan (BicycleModel\vehicle_model\alpha_f); */
	xx_V[6] = -xx_P[6] * tan (xx_V[10]);

	/* BicycleModel\vehicle_model\f_y_r = -C_ar * tan (BicycleModel\vehicle_model\alpha_r); */
	xx_V[7] = -xx_P[7] * tan (xx_V[11]);

	/* if abs (BicycleModel\vehicle_model\f_y_f) > BicycleModel\vehicle_model\h_s_f */
	if (XXAbsolute (xx_V[6]) > xx_V[8])
	{
		/* BicycleModel\vehicle_model\F_y_f = ((-mu * BicycleModel\vehicle_model\W_f) * sign (BicycleModel\vehicle_model\alpha_f)) * (1 - ((mu * BicycleModel\vehicle_model\W_f) / ((4 * C_af) * abs (tan (BicycleModel\vehicle_model\alpha_f))))); */
		xx_V[12] = ((-xx_P[1] * xx_V[5]) * XXSign (xx_V[10])) * (1.0 - ((xx_P[1] * xx_V[5]) / ((4.0 * xx_P[6]) * XXAbsolute (tan (xx_V[10])))));
	}
	else
	{
		/* BicycleModel\vehicle_model\F_y_f = BicycleModel\vehicle_model\f_y_f; */
		xx_V[12] = xx_V[6];
	}

	/* if abs (BicycleModel\vehicle_model\f_y_r) > BicycleModel\vehicle_model\h_s_r */
	if (XXAbsolute (xx_V[7]) > xx_V[9])
	{
		/* BicycleModel\vehicle_model\F_y_r = ((-mu * BicycleModel\vehicle_model\W_r) * sign (BicycleModel\vehicle_model\alpha_r)) * (1 - ((mu * BicycleModel\vehicle_model\W_r) / ((4 * C_ar) * abs (tan (BicycleModel\vehicle_model\alpha_r))))); */
		xx_V[13] = ((-xx_P[1] * xx_V[4]) * XXSign (xx_V[11])) * (1.0 - ((xx_P[1] * xx_V[4]) / ((4.0 * xx_P[7]) * XXAbsolute (tan (xx_V[11])))));
	}
	else
	{
		/* BicycleModel\vehicle_model\F_y_r = BicycleModel\vehicle_model\f_y_r; */
		xx_V[13] = xx_V[7];
	}

	/* if abs (motor\Limit\output) > 0.025 */
	if (XXAbsolute (xx_V[35]) > 0.025)
	{
		/* BicycleModel\vehicle_model\d_v = (((-m * motor\Limit\output) * BicycleModel\vehicle_model\r + BicycleModel\vehicle_model\F_y_f) + BicycleModel\vehicle_model\F_y_r) / m; */
		xx_R[0] = (((-xx_P[3] * xx_V[35]) * xx_s[1] + xx_V[12]) + xx_V[13]) / xx_P[3];

		/* BicycleModel\vehicle_model\d_r = (BicycleModel\vehicle_model\F_y_f * BicycleModel\vehicle_model\a - BicycleModel\vehicle_model\F_y_r * BicycleModel\vehicle_model\b) / I_zz; */
		xx_R[1] = (xx_V[12] * xx_V[0] - xx_V[13] * xx_V[1]) / xx_V[2];
	}
	else
	{
		/* BicycleModel\vehicle_model\d_v = 0; */
		xx_R[0] = 0.0;

		/* BicycleModel\vehicle_model\d_r = 0; */
		xx_R[1] = 0.0;
	}

	/* PosCalc\P_GNSS = transpose (PosCalc\R) * PosCalc\P_1; */
	XXMatrixTranspose (&xx_M[3], &xx_M[2]);
	/* PosCalc\P_GNSS = transpose (PosCalc\R) * PosCalc\P_1; */
	XXMatrixMul (&xx_M[1], &xx_M[3], &xx_M[0]);

	/* PosCalc\temp_x = PosCalc\x + PosCalc\P_GNSS[1]; */
	xx_V[46] = xx_s[5] + xx_M[1].mat[0];

	/* PosCalc\temp_y = PosCalc\y + PosCalc\P_GNSS[2]; */
	xx_V[47] = xx_s[6] + xx_M[1].mat[1];


	/* increment the step counter */
	model_instance->steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (xx_ModelInstance* model_instance)
{
	/* w_o = motor\wheel\output; */
	xx_V[77] = xx_s[3];

	/* delta_fl_o = pvg_actuator\TransferFunction\state; */
	xx_V[85] = xx_s[7];

	/* delta_fr_o = pvg_actuator\TransferFunction1\state; */
	xx_V[88] = xx_s[8];

	/* r_a = PosCalc\r_a; */
	xx_V[90] = xx_R[4];

	/* w_l_o = motor\wheel\output; */
	xx_V[74] = xx_s[3];

	/* w_r_o = motor\wheel\output; */
	xx_V[78] = xx_s[3];

	/* delta_fl = pvg_actuator\encoder1\AngleToLinearDistance1\output; */
	xx_V[84] = xx_V[59];

	/* delta_fr = pvg_actuator\encoder\AngleToLinearDistance1\output; */
	xx_V[87] = xx_V[49];

	/* delta_f = pvg_actuator\Limit\output; */
	xx_V[91] = xx_V[68];

	/* w_l_p = motor\encoder2\AngleToLinearDistance1\output; */
	xx_V[75] = xx_V[25];

	/* w_l_s = motor\encoder2\AngleToLinearDistance3\output; */
	xx_V[76] = xx_V[27];

	/* w_r_p = motor\encoder1\AngleToLinearDistance1\output; */
	xx_V[79] = xx_V[15];

	/* w_r_s = motor\encoder1\AngleToLinearDistance3\output; */
	xx_V[80] = xx_V[17];

	/* delta_fl_s = pvg_actuator\encoder1\AngleToLinearDistance3\output; */
	xx_V[86] = xx_V[61];

	/* delta_fr_s = pvg_actuator\encoder\AngleToLinearDistance3\output; */
	xx_V[89] = xx_V[51];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void XXCalculateFinal (xx_ModelInstance* model_instance)
{

}

/* this method is called after all calculations are performed */
void XXModelTerminate(xx_ModelInstance* model_instance)
{
}


